 

废话少说，直接开始学习！

# 元字符

元字符是构造[正则表达式](https://so.csdn.net/so/search?q=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1001.2101.3001.7020)的一种基本元素。

. ：匹配除换行符以外的任意字符

w：匹配字母或数字或下划线或汉字

s：匹配任意的空白符

d：匹配数字

b：匹配单词的开始或结束

^：匹配字符串的开始

$：匹配字符串的结束

```bash
匹配有abc开头的字符串：abc或者^abc 匹配8位数字的QQ号码：^dddddddd$ 匹配1开头11位数字的手机号码：^1dddddddddd$
```

# 重复限定符

正则没提供办法处理这些重复的元字符吗？答案肯定是有的。

\*：重复零次或更多次

+：重复一次或更多次

?：重复零次或一次

{n}：重复n次

{n,}：重复n次或更多次

{n,m}：重复n到m次

有了这些限定符之后，我们就可以对之前的正则表达式进行改造了，比如：

```bash
匹配8位数字的QQ号码：^d{8}$ 匹配1开头11位数字的手机号码：^1d{10}$ 匹配银行卡号是14~18位的数字：^d{14,18}$ 匹配以a开头的，0个或多个b结尾的字符串^ab*$
```

# 分组（）

限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要ab同时被限定那怎么办呢？

正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。

因此当我们要匹配多个ab时，我们可以这样。

```bash
如匹配字符串中包含0到多个ab开头：^(ab)*
```

# 转义

正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\\即可。

```bash
匹配字符串中包含0到多个ab开头：^(\(ab\))*
```

# 条件或 |

回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有130/131/132/155/156/185/186/145/176等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？

> 正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。

那么我们就可以用或条件来处理这个问题

```cobol
^(130|131|132|155|156|185|186|145|176)\d{8}$
```

# 区间\[ \]

看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？  
实际是有的

> 正则提供一个元字符中括号 \[\] 来表示区间条件。
> 
> 1.  限定0到9 可以写成\[0-9\]
>     
> 2.  限定A-Z 写成\[A-Z\]
>     
> 3.  限定某些数字 \[165\]
>     

那上面的正则我们还改成这样：

```cobol
^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$
```

# 正则进阶之零宽断言

> 1.  断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，  
>     意思正则也可以像人类那样断定什么什么，比如"ss1aa2bb3",正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.
>     
> 2.  零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。
>     

我们来举个栗子：  
假设我们要用爬虫抓取csdn里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构

```xml
"<span class="read-count">阅读数：641</span>"
```

其中也就‘641’这个是变量，也就是说不同文章不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果正则应该怎么匹配呢？下面先来讲几种类型的断言：

> 1.  正向先行断言（正前瞻）：
>     
> 
> *   语法：（?=pattern）
>     
> *   作用：匹配pattern表达式的前面内容，不返回本身。
>     

这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到‘’前面的数字内容  
按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:(?=) 就可以匹配到前面的内容了。  
匹配什么内容呢？如果要所有内容那就是：

```cobol
 String reg=".+(?=</span>)";  String test = "<span class=\"read-count\">阅读数：641</span>"; Pattern pattern = Pattern.compile(reg); Matcher mc= pattern.matcher(test); while(mc.find()){   System.out.println("匹配结果：")   System.out.println(mc.group()); } //匹配结果：//<span class="read-count">阅读数：641
```

可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \\d,那可以改成：

```cobol
String reg="\\d+(?=</span>)";String test = "<span class=\"read-count\">阅读数：641</span>";Pattern pattern = Pattern.compile(reg);Matcher mc=    pattern.matcher(test);while(mc.find()){  System.out.println(mc.group());} //匹配结果：//641
```

大功告成！

> 1.  正向后行断言（正后顾）:
>     
> 
> *   语法：（?<=pattern）
>     
> *   作用：匹配pattern表达式的后面的内容，不返回本身。
>     

有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。

上面的栗子，我们也可以用后行断言来处理.

```cobol
 //(?<=<span class="read-count">阅读数：)\d+ String reg="(?<=<span class=\"read-count\">阅读数：)\\d+";  String test = "<span class=\"read-count\">阅读数：641</span>"; Pattern pattern = Pattern.compile(reg); Matcher mc=    pattern.matcher(test);         while(mc.find()){             System.out.println(mc.group());         } //匹配结果：//641
```

就这么简单。

> 1.  负向先行断言（负前瞻）
>     
> 
> *   语法：(?!pattern)
>     
> *   作用：匹配非pattern表达式的前面内容，不返回本身。
>     

有正向也有负向，负向在这里其实就是非的意思。  
举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”  
现在要找到不是'的花朵'前面的祖国  
用正则就可以这样写：

```scss
祖国(?!的花朵)
```

> 1.  负向后行断言（负后顾）
>     
> 
> *   语法：(?<!pattern)
>     
> *   作用：匹配非pattern表达式的后面内容，不返回本身。
>     

# 正则进阶之捕获和非捕获

单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”

> 捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。

而根据命名方式的不同，又可以分为两种组：

> 1.  数字编号捕获组：  
>     语法：(exp)  
>     解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。  
>     比如固定电话的：020-85653333  
>     正则表达式为：(0\\d{2})-(\\d{8})  
>     按照左括号的顺序，这个表达式有如下分组：
>     

| 序号 | 编号 | 分组 | 内容 |
| --- | --- | --- | --- |
| 0 | 0 | (0\\d{2})-(\\d{8}) | 020-85653333 |
| 1 | 1 | (0\\d{2}) | 020 |
| 2 | 2 | (\\d{8}) | 85653333 |

我们用Java来验证一下：

```cobol
 String test = "020-85653333";         String reg="(0\\d{2})-(\\d{8})";         Pattern pattern = Pattern.compile(reg);         Matcher mc= pattern.matcher(test);         if(mc.find()){             System.out.println("分组的个数有："+mc.groupCount());             for(int i=0;i<=mc.groupCount();i++){                 System.out.println("第"+i+"个分组为："+mc.group(i));             }        }
```

输出结果：

```cobol
分组的个数有：2第0个分组为：020-85653333第1个分组为：020第2个分组为：85653333
```

可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。

> 1.  命名编号捕获组：  
>     语法：(?exp)
>     
>     解释：分组的命名由表达式中的name指定  
>     比如区号也可以这样写:(?\\0\\d{2})-(?\\d{8})  
>     按照左括号的顺序，这个表达式有如下分组：

| 序号 | 名称 | 分组 | 内容 |
| --- | --- | --- | --- |
| 0 | 0 | (0\\d{2})-(\\d{8}) | 020-85653333 |
| 1 | quhao | (0\\d{2}) | 020 |
| 2 | haoma | (\\d{8}) | 85653333 |

用代码来验证一下：

```cobol
1String test = "020-85653333";2        String reg="(?<quhao>0\\d{2})-(?<haoma>\\d{8})";3        Pattern pattern = Pattern.compile(reg);4        Matcher mc= pattern.matcher(test);5        if(mc.find()){6            System.out.println("分组的个数有："+mc.groupCount());7            System.out.println(mc.group("quhao"));8            System.out.println(mc.group("haoma"));9        }
```

输出结果：

```cobol
分组的个数有：2分组名称为:quhao,匹配内容为：020分组名称为:haoma,匹配内容为：85653333
```

> 1.  非捕获组：  
>     语法：(?:exp)  
>     解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。
>     

比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：

```scss
(?:\0\d{2})-(\d{8})
```

| 序号 | 编号 | 分组 | 内容 |
| --- | --- | --- | --- |
| 0 | 0 | (0\\d{2})-(\\d{8}) | 020-85653333 |
| 1 | 1 | (\\d{8}) | 85653333 |

验证一下：

```cobol
 String test = "020-85653333";         String reg="(?:0\\d{2})-(\\d{8})";         Pattern pattern = Pattern.compile(reg);         Matcher mc= pattern.matcher(test);         if(mc.find()){                 System.out.println("分组的个数有："+mc.groupCount());                 for(int i=0;i<=mc.groupCount();i++){                     System.out.println("第"+i+"个分组为："+mc.group(i));                 }        }
```

输出结果：

```cobol
分组的个数有：1第0个分组为：020-85653333第1个分组为：85653333
```

# 正则进阶之反向引用

上面讲到捕获，我们知道：**捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用**。

根据捕获组的命名规则，反向引用可分为：

> 1.  数字编号组反向引用：\\k
>     
>     或\\number
>     
> 2.  命名编号组反向引用：\\k
>     
>     或者\\'name'
>     

好了 讲完了，懂吗？不懂！！！  
可能连前面讲的捕获有什么用都还不懂吧？  
其实只是看完捕获不懂不会用是很正常的！  
因为捕获组通常是和反向引用一起使用的

上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用  
注意两个字眼：“内容” 和 “使用”  
这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住  
那这里所说的“使用”是怎样使用呢？

因为它的作用主要是用来查找一些重复的内容或者做替换指定字符。

还是举栗子吧：  
比如要查找一串字母"aabbbbgbddesddfiid"里成对的字母  
如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的，  
现在我们先用程序思维理一下思路：

> *   1）匹配到一个字母
>     
> *   2）匹配第下一个字母，检查是否和上一个字母是否一样
>     
> *   3）如果一样，则匹配成功，否则失败
>     

这里的思路2中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？  
这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件  
好了，有思路就要实践  
首先匹配一个字母：\\w  
我们需要做成分组才能捕获，因此写成这样：(\\w)

那这个表达式就有一个捕获组：（\\w）  
然后我们要用这个捕获组作为条件，那就可以：(\\w)\\1  
这样就大功告成了  
可能有人不明白了，\\1是什么意思呢？  
还记得捕获组有两种命名方式吗，**一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名**  
**在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的**  
因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \\k<1>或者\\1  
当然，通常都是是后者。  
我们来测试一下：

```cobol
String test = "aabbbbgbddesddfiid";        Pattern pattern = Pattern.compile("(\\w)\\1");        Matcher mc= pattern.matcher(test);        while(mc.find()){            System.out.println(mc.group());         }
```

输出结果：

```less
aabbbbddddii
```

嗯，这就是我们想要的了。  
在举个替换的例子，假如想要把字符串中abc换成a

```cobol
String test = "abcbbabcbcgbddesddfiid";String reg="(a)(b)c";System.out.println(test.replaceAll(reg, "$1"));;
```

输出结果：

```undefined
abbabcgbddesddfiid
```

# 正则进阶之贪婪和非贪婪

**1、贪婪**

我们都知道，贪婪就是不满足，尽可能多的要。  
在正则中，贪婪也是差不多的意思:

> 贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。  
> 特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。

前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：

```cobol
\d{3,6}
```

用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。  
如

```cobol
String reg="\\d{3,6}";String test="61762828 176 2991 871";System.out.println("文本："+test);System.out.println("贪婪模式："+reg);Pattern p1 =Pattern.compile(reg);Matcher m1 = p1.matcher(test);   while(m1.find()){      System.out.println("匹配结果："+m1.group(0));   }
```

输出结果：

```cobol
文本：61762828 176 2991 44 871贪婪模式：\d{3,6}匹配结果：617628匹配结果：176匹配结果：2991匹配结果：871
```

由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。  
一个量词就如此贪婪了，  
那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？

> 是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。

```cobol
String reg="(\\d{1,2})(\\d{3,4})";String test="61762828 176 2991 87321";System.out.println("文本："+test);System.out.println("贪婪模式："+reg);Pattern p1 =Pattern.compile(reg);Matcher m1 = p1.matcher(test);  while(m1.find()){      System.out.println("匹配结果："+m1.group(0));    }
```

输出结果：

```cobol
文本：61762828 176 2991 87321贪婪模式：(\d{1,2})(\d{3,4})匹配结果：617628匹配结果：2991匹配结果：87321
```

> 1.  “617628” 是前面的\\d{1,2}匹配出了61，后面的匹配出了7628
>     
> 2.  "2991" 是前面的\\d{1,2}匹配出了2 ，后面的匹配出了991
>     
> 3.  "87321"是前面的\\d{1,2}匹配出了87，后面的匹配出了321
>     

再来一个例子

```java
import java.util.regex.*;class Untitled {	public static void main(String[] args) {		String reg="(\\d{1,2})(\\d{2,4})(\\d{1,2})";		String test="61762828 176 2991 871";		System.out.println("文本："+test);		System.out.println("贪婪模式："+reg);		Pattern p1 =Pattern.compile(reg);		Matcher m1 = p1.matcher(test);		while(m1.find()){			System.out.println("匹配结果："+m1.group(0));		}	}}
```

输出结果：

```bash
文本：61762828 176 2991 871贪婪模式：(\d{1,2})(\d{2,4})(\d{1,2})匹配结果：61762828匹配结果：2991
```

1.  “61762828” 是前面的\\d{1,2}匹配出了61，后面\\d{2,4}匹配出了7628，后面\\d{1,2}匹配出了28
    
2.  "2991" 是前面的\\d{1,2}匹配出了2 ，后面\\d{2,4}匹配出了99，后面\\d{1,2}匹配出了1
    

从执行结果来看，贪婪不是严格从左到右匹配，不然2991就匹配不出来了，而是会丢弃一些字符尽可能的匹配到字符。

**2、懒惰（非贪婪）**

> 懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。  
> 特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。

懒惰量词是在贪婪量词后面加个“？”

| 代码 | 说明 |
| --- | --- |
| \*? | 重复任意次，但尽可能少重复 |
| +? | 重复1次或更多次，但尽可能少重复 |
| ?? | 重复0次或1次，但尽可能少重复 |
| {n,m}? | 重复n到m次，但尽可能少重复 |
| {n,}? | 重复n次以上，但尽可能少重复 |

```cobol
String reg="(\\d{1,2}?)(\\d{3,4})";        String test="61762828 176 2991 87321";        System.out.println("文本："+test);        System.out.println("贪婪模式："+reg);        Pattern p1 =Pattern.compile(reg);        Matcher m1 = p1.matcher(test);        while(m1.find()){            System.out.println("匹配结果："+m1.group(0));        }
```

输出结果：

```cobol
文本：61762828 176 2991 87321贪婪模式：(\d{1,2}?)(\d{3,4})匹配结果：61762匹配结果：2991匹配结果：87321
```

解答：

> “61762” 是左边的懒惰匹配出6，右边的贪婪匹配出1762  
> "2991" 是左边的懒惰匹配出2，右边的贪婪匹配出991  
> "87321" 左边的懒惰匹配出8，右边的贪婪匹配出7321

# 正则进阶之反义

前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：

| 元字符 | 解释 |
| --- | --- |
| \\W | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \\S | 匹配任意不是空白符的字符 |
| \\D | 匹配任意非数字的字符 |
| \\B | 匹配不是单词开头或结束的位置 |
| \[^x\] | 匹配除了x以外的任意字符 |
| \[^aeiou\] | 匹配除了aeiou这几个字母以外的任意字符 |

# 正则表达式匹配网站

[http://tool.chinaz.com/regex](http://tool.chinaz.com/regex)

# 附录，常用正则表达式

```bash
一、校验数字的表达式       1 数字：^[0-9]*$      2 n位的数字：^\d{n}$      3 至少n位的数字：^\d{n,}$      4 m-n位的数字：^\d{m,n}$      5 零和非零开头的数字：^(0|[1-9][0-9]*)$      6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$      7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$      8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$      9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$    10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$    11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$    12 非零的负整数：^\-[1-9][]0-9*$ 或 ^-[1-9]\d*$    13 非负整数：^\d+$ 或 ^[1-9]\d*|0$    14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$    15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$    16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$    17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$    18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$    19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$  二、校验字符的表达式      1 汉字：^[\u4e00-\u9fa5]{0,}$      2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$      3 长度为3-20的所有字符：^.{3,20}$      4 由26个英文字母组成的字符串：^[A-Za-z]+$      5 由26个大写英文字母组成的字符串：^[A-Z]+$      6 由26个小写英文字母组成的字符串：^[a-z]+$      7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$      8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$      9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$    10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$    11 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+    12 禁止输入含有~的字符：[^~\x22]+  三、特殊需求表达式      1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$      2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?      3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$      4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$      5 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX")：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$       6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}      7 身份证号(15位、18位数字)：^\d{15}|\d{18}$      8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$      9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$    10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$    11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$      12 日期格式：^\d{4}-\d{1,2}-\d{1,2}    13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$    14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$     15 钱的输入格式：    16    1).有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$     17    2).这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$     18    3).一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$     19    4).这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$     20    5).必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$     21    6).这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$     22    7).这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$     23    8). 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$     24    备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$    26 中文字符的正则表达式：[\u4e00-\u9fa5]    27 双字节字符：[^\x00-\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))    28 空白行的正则表达式：\n\s*\r    (可以用来删除空白行)    29 HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? />    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)    30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)    31 腾讯QQ号：[1-9][0-9]{4,}    (腾讯QQ号从10000开始)    32 中国邮政编码：[1-9]\d{5}(?!\d)    (中国邮政编码为6位数字)    33 IP地址：\d+\.\d+\.\d+\.\d+    (提取IP地址时有用)    34 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))
```

好了，正则表达式的基本用法就讲到这里了，其实它还有非常多的知识点以及元字符，我们在此只列举了部分元字符和语法来讲，旨在给那些不懂正则或者想学正则但有看不下去文档的人做一个快速入门级的教程，看完本教程，即使你不能写出高大上的正则，至少也能写一些简单的正则或者看得懂别人写的正则了。

* * *

—————————————

文章来源：公众号码农沉思录、数据库开发、Java基基

本文转自 <https://blog.csdn.net/William0318/article/details/102775217>，如有侵权，请联系删除。